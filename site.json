{"title":"Flow.apex","githubRepo":"Click-to-Cloud/Flow.apex","googleAnalytics":"","index":{"title":"Home","description":"Flow.apex is a library to help you weave functions in a procedural style.","content":" Build Funcs Flow.apex uses procedral structures to build Funcs in the form of Flows. Code Blocks Flow.apex not only creates Funcs, but also creates executable blocks of code. FlowScript Flow.apex includes a script that naturally integrates with R.apex and all of your Funcs. ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/flow-apex/./","children":{"docs":{"title":"Docs","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/flow-apex/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/flow-apex/docs/search.html"},"Flow":{"title":"Flows","description":"Flows and Funcs","layout":"guide","icon":"flash","weight":1,"content":" {$page.description} What is a Flow? A Flow is a Func that is created in a procedural way by weaving other Funcs. According to R.apex, we normally have two ways to create a Func. Func Composition An example of this is below: Func notEqBy3 = (Func)R.complement.run(R.equals.apply(3)); In this way, we compose a large Func out of small Funcs. This more functional way of creating Funcs is limited by the number of existing Funcs that we can use, and the complexity of composing them. Basically, it works perfectly for small and simple functions, but not so good with large and complicated functions. Func Inheritance Another way of creating a Func is by subclassing Func. public class CustomFunc extends Func { public CustomFunc() { super(1); } public override Object exec(Object arg) { // Custom logic here return ...; } } We write our same old logic here in the custom Func, and wraps our complex code in a custom Func. The issue, however, is that creating custom Funcs all the time is quite heavy. We kind of miss the adorable composing abilities from the first approach. Flow Funcs So here comes Flow.apex for the rescue. Func f = new Flow() .inputAs('a', 'b').returnInteger() .var('sum = a + b') .doReturn('sum'); Flows, subclassing from Func, come with another style of functional composition, the procedural style of functional chaining. The intention of Flow.apex is not to promote procedural programming camouflaged in functional programming. Instead, it is just a bridge between the pure functional way and the pure procedural way, trying to glue the Funcs to create the ultimate complex monster by utilizing a little power of both. So the takeaway is to try to keep your Flow logic as simple as possible, and reuse as many Funcs as possible. Flow Concepts Before we dive in, we need to clarify several concepts. Flow A Flow is an object of type Flow, and it is a Func. A Flow is a Block decorated with arguments and return types. Block A Block is a group of executable codes. A flow is backed by a block. A block contains a list of statements. Statement A Statement is a line of executable code, usually grouped in a block. Flows Flows are just custom Funcs in a more declarative way. Apex in Salesforce does not support anonymous inner classes, and that makes it hard to dynamically create Funcs. Flow.apex is just a workaround to make that less painful. Flows are just blocks of executable codes. Normally, flows can be used in one of the two forms. Flow as a Func A Func takes arguments, returns values and possibly has a name. This is where flows are like Funcs. Flow f = new Flow('sum') .inputAs('a', 'b').returnInteger() .doReturn('a + b'); This Flow Func is equivalent to the following function: Integer sum(Integer a, Integer b); And it works just like a sum Func. Object result = f.run(1, 2); // 3 Flow as a Block Blocks are the internal implementations of flows. And naturally flows expose the behavior of blocks. A block is a group of code that operates on a set of variables. Flow f = new Flow() .var('sum = a + b'); Blocks do not need any arguments, or return values. All they need is a set of variables to work on. Map result = (Map)f.execute(new Map{ 'a' = 1, 'b' = 2, 'sum' = null }); Flow Funcs Here are the factors we need take into consideration when we define a Flow Func. Func Parameters We need to give meaningful Func parameter names, although Func parameters always have type as Object. Flow f = new Flow() .inputAs('a', 'b'); Here we define a Flow Func that takes parameter a and parameter b. Func Return Type We can also specify the return type of the Flow Func, though not required. Flow f = new Flow() .inputAs('a', 'b').returnInteger(); returnInteger() indicates that this Flow Func returns an Integer, and when we do the doReturn, Flow.apex will try to convert the returning value to the return type we have previously declared. Func Name Again, Flow name is not required. Flow f = new Flow('f'); The only benefit of declaring a Flow Func with a name is to add this Flow Func to the Flow APIs(used in FlowScript) for you, which you can do it by yourself later. Flow.addFunc('f', f); Do the Return We return the value by calling doReturn or doReturnRaw. The difference is subtle: Flow f = new Flow() .doReturn('\"message\"'); v.s Flow f = new Flow() .doReturnRaw('message'); doReturn will try to treat your String as FlowScripts, while doReturnRaw will not. Blocks We can create blocks by calling Flow.block(). Flow.block() .var('name = \"Wilson\"'); Blocks own their statements and local variables, and can mutate global variables to share information with outside of the blocks. Blocks are seldom used standalone. Instead, they are mostly used combined with various controlling structures. Deferred Execution Each statement in a block encapsulates a deferred execution of code. Flow f = new Flow() .var('sum = a + b'); f.execute(...); Statements are not executed until execute or run is called on Func, or execute is called on Block. Variables Variables are ubiquitous in flows, and they act as the carriers of data. We can access the variable values like this: Flow f = new Flow() .var('b', Flow.getVar('a')); Here we get the value of a by calling Flow.getVar(String), and set it to another variable by calling var(String, Object). Variables in Flow.apex have scopes. In terms of scopes, variables are divided into global variables and local variables in a block. Global variables Global variables are passed in to the block from outside. Blocks can mutate the values of global variables, but can never add or remove global variables. Local variables Local variables are created inside the block. The blocks are responsible for managing the lifecycle of the local variables. Local variables are NOT visible to outside of the block. The global variables and the local variables share the names. That means we cannot have variables with duplicate names in the same block. A variable can either be global or local, and there is no variable overridden in Flow.apex. That is to say, if we have code like this, Flow f = new Flow() .var('sum = a + b'); If the Flow accepts sum from the outside variables, it will use it as a global variable and set its value. Otherwise it will create a local variable and set its value. It will not create a local variable with the same name as the global variable, and override it. We can print the debugging information of all the variables in the current block. Flow.block() .debug(); Functions Flows actually weave Funcs into a complex Func. It's just that we have not noticed that. Flow f = new Flow() .var('sum = concat(a, b)'); In this Flow, R.concat is called with a and b. This is the same as below: Flow f = new Flow() .var('sum', Flow.call(R.concat, Flow.getVar('a'), Flow.getVar('b'))); This snippet is more cumbersome, but clearly explains the Func-invoking thing here. All Funcs from R.apex have already been imported to Flow.apex, and you can freely use them. In order to import your own Funcs, do this: Flow.addFunc('customFunc', new CustomFunc()); Make sure you import the Funcs you need before you actually use them. Functions Flows actually weave Funcs into a complex Func. It's just that we have not noticed that. Flow f = new Flow() .var('sum = concat(a, b)'); In this Flow, R.concat is called with a and b. This is the same as below: Flow f = new Flow() .var('sum', Flow.call(R.concat, Flow.getVar('a'), Flow.getVar('b'))); This snippet is more cumbersome, but clearly explains the Func-invoking thing here. All Funcs from R.apex have already been imported to Flow.apex, and you can freely use them. In order to import your own Funcs, do this: Flow.addFunc('customFunc', new CustomFunc()); Make sure you import the Funcs you need before you actually use them. Branch Control Flow.apex offers branch control with if and switch. If Statement We have if and if not, and we can append else blocks. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doIf( 'a == 1', Flow.block().doReturn(1) ); Or Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doIf( 'a == 1', Flow.block().doReturn(1), Flow.block().doReturn(2) ); Switch Statement We have switch to handle multiple branching cases. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('word = \"a\"') .doSwitch('word', new List{ 'a', Flow.block().var('output = debug(\"Matched\")'), 'b', Flow.block().var('output = debug(\"Not Matched\")') }); Or we can have more complicated switching. Flow f = new Flow() .inputAs('n').returnInteger() .doSwitch('n', new List{ Flow.s('n == 1'), Flow.block().var('output = debug(\"Matched\")'), Flow.s('n != 1'), Flow.block().var('output = debug(\"Not Matched\")') }); Here Flow.s(String) convert a String into a deferred condition check for swtich. Loop Control Flow.apex has three types of loop control. For Loop Here is the normal for loop that we can use. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doFor('i = 0; i < 10; i = i + 1', Flow.block() .var('output = debug(i)') ); Notice that here we use i = i + 1, as i++ is not supported in Flow.apex. For-In Loop We can also use for ... in like structure. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doFor('i in range(0, 10)', Flow.block() .var('output = debug(i)') ); While Loop We support the use of while. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('i = 0') .doWhile('i < 10', Flow.block() .var('output = debug(i)') .var('i = i + 1') ); To better control the loops, we have break and continue available. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('i = 0') .doWhile('i < 10', Flow.block() .doIf('i == 3', Flow.block() .doBreak() ) .var('output = debug(i)') .var('i = i + 1') ); Recursion We can easily achieve recursion in Flow.apex. Flow f = new Flow() .inputAs('n').returnInteger() .doIf( 'n == 0', Flow.block() .doReturn(0) ) .var('ret = 2 + this(n - 1)') .doReturn('ret'); Here this(n - 1) is calling Flow f, with argument n - 1. ","srcFilePath":"src/pages/docs/Flow/index.md","id":"Flow","location":"/docs/Flow/","url":"/flow-apex/docs/Flow/"},"FlowScript":{"title":"FlowScript","description":"FlowScript","layout":"guide","icon":"cloud","weight":4,"content":" {$page.description} What is FlowScript? FlowScript is a small scripting language packaged with Flow.apex. FlowScript is used to convert javascript-like scripts into Flow.apex code. How does FlowScript work? FlowScript bascially is just an interpreter from a more readable script to Flow.apex code. Flow f = new Flow() .var('n = n + 1'); This embedded FlowScript is then translated into this: Flow f = new Flow() .var('n', Flow.s('n + 1')); Flow.s(String) is a tool used to convert Strings into deferred Flow.apex code invocations. It eventually translates the script into: Flow f = new Flow() .var('n', Flow.call(R.add.apply(1), Flow.getVar('n'))); The purpose of FlowScript is to make the code easier to read, and fundamentally it does not change the code logic. The interpretation of FlowScript happens only once when the Flow is created. Therefore further performance penalty is avoided. FlowScript Evaluation We can evaluate FlowScript independently from Flow.apex. Object value = Flow.eval('add(a, b)', new Map{ 'a' = 1, 'b' = 2 }); FlowScript Syntax FlowScript follows most of JavaScript syntax, with these exceptions: Functions instead of methods FlowScript supports only functions like add(1, 2), not a.add(1, 2). Reference of this In FlowScript, this always refers to the current Flow object. Supported Unary Operators | Operator | Description | | -------- | ----------- | | - | Negate the number | | ! | Negate the boolean | | ++(prefixed) | Increment the number | | --(prefixed) | Decrement the number | Supported Binary Operators | Operator | Description | | -------- | ----------- | | == | Equals | | != | Not Equals | | < | Less than | | | Greater than | | = | Greater than or equals | | + | Add | | - | Minus | | * | Multiply | | / | Divide | | % | Modulo | Supported Logical Operators | Operator | Description | | -------- | ----------- | | ! | Negate the boolean | | && | Logical And | | \\|\\| | Logical Or | Supported Ternary Operators | Operator | Description | | -------- | ----------- | | ? : | If ... then ... else ... | Array Literal Flow f = new Flow() .var('a = [\"a\", \"b\"]'); Map Literal Flow f = new Flow() .var('a = { \"name\" = \"value\" }'); ","srcFilePath":"src/pages/docs/FlowScript/index.md","id":"FlowScript","location":"/docs/FlowScript/","url":"/flow-apex/docs/FlowScript/"},"Methods":{"children":{"block":{"title":"Block Methods","description":"Block Methods","layout":"guide","icon":"code-file","weight":4,"content":" {$page.description} Block Trigger These methods trigger the block to run. | Method | Description | | ----------- | ----------- | | execute(Map&lt;String, Object&gt;) | Execute the block with the variables | Assign Variables These methods assign the variable values. | Method | Description | | ----------- | ----------- | | var(String) | Run the simplified assignment | | var(String, Object) | Assign the value to the variable with the name | If Control These methods do the if control. | Method | Description | | ----------- | ----------- | | doIf(Object, Block) | If ... then ... | | doIf(Object, Block, Block) | If ... then ... else ... | | doIfNot(Object, Block, Block) | If not ... then ... else ... | | doIfNot(Object, Block) | If not ... then ... | For Control These methods do the for control. | Method | Description | | ----------- | ----------- | | doFor(String, Object, Object, Object, Block) | for i = 0; i != 10; i = i + 1 loop | | doFor(String, Object, Block) | for ... in loop | | doFor(String, Block) | Simplified for loop statement | While Control These methods do the while control. | Method | Description | | ----------- | ----------- | | doWhile(Object, Block) | while ..., do ... | Switch Control These methods do the switch control. | Method | Description | | ----------- | ----------- | | doSwitch(Object, List&lt;Object&gt;) | switch ... case ... | Break && Continue These methods are useful in loop and switches. | Method | Description | | ----------- | ----------- | | doBreak() | Break | | doContinue() | Continue | Debug These methods are useful for debugging. | Method | Description | | ----------- | ----------- | | debug() | Print the variables in the current block | ","srcFilePath":"src/pages/docs/Methods/block.md","id":"block","location":"/docs/Methods/block.html","url":"/flow-apex/docs/Methods/block.html"},"creation":{"title":"Creation Methods","description":"Creation Methods","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} Constructors | Constructor | Description | | ----------- | ----------- | | Flow() | Create a default Flow | | Flow(String) | Create a Flow with the given name | ","srcFilePath":"src/pages/docs/Methods/creation.md","id":"creation","location":"/docs/Methods/creation.html","url":"/flow-apex/docs/Methods/creation.html"},"function":{"title":"Function Methods","description":"Function Methods","layout":"guide","icon":"code-file","weight":3,"content":" {$page.description} Func Arguments These methods specify the arguments of the Flow Func. | Method | Description | | ----------- | ----------- | | inputAs(String) | Rename first argument | | inputAs(String, String) | Rename first two arguments | | inputAs(String, String, String) | Rename first three arguments | | inputAs(List&lt;String&gt;) | Rename the givne arguments | Func Return Type These methods specify the return type of the Flow Func. | Method | Description | | ----------- | ----------- | | returnObject(Type) | Specify the return type | | returnObject() | Return Object | | returnBoolean() | Return Boolean | | returnInteger() | Return Integer | | returnLong() | Return Long | | returnDouble() | Return Double | | returnDecimal() | Return Decimal | | returnString() | Return String | | returnList() | Return List&lt;Object&gt; | | returnSet() | Return Set&lt;String&gt; | | returnMap() | Return Map&lt;String, Object&gt; | | returnSObject() | Return SObject | | returnDate() | Return Date | | returnTime() | Return Time | | returnDatetime() | Return Datetime | | returnFunc() | Return Func | Func Do Return These methods return a value from the Flow Func. | Method | Description | | ----------- | ----------- | | doReturn(Object) | Return the value, treating Strings as FlowScript | | doReturnRaw(Object) | Return the value, treating Strings as raw | Func Trigger These methods trigger the Flow Func to run. | Method | Description | | ----------- | ----------- | | run(...) | Run the Func with the arguments | | runN(List&lt;Object&gt;) | Run the Func with the list of arguments | ","srcFilePath":"src/pages/docs/Methods/function.md","id":"function","location":"/docs/Methods/function.html","url":"/flow-apex/docs/Methods/function.html"},"static":{"title":"Static Methods","description":"Static Methods","layout":"guide","icon":"code-file","weight":5,"content":" {$page.description} this Placeholder Flow.apex has a placeholder for the current Flow, and it is Flow.self. Flow f = new Flow() .inputAs('n').returnInteger() .doIf( Flow.call(R.equals.apply(0), Flow.getVar('n')), Flow.block() .doReturn(0) ) .var('ret', Flow.call(R.add.apply(2), Flow.call(Flow.self, Flow.call(R.dec, Flow.getVar('n'))))) .doReturn(Flow.getVar('ret')); FlowScript Interpretation Using Flow.s(String), we can convert Strings into Flow.apex invocations. Flow f = new Flow() var('n', Flow.s('i')); FlowScript Evaluation We can evaluate the FlowScript independently from Flows. Object result = Flow.eval('add(1, 2)'); FlowScript Evaluation We can evaluate the FlowScript independently from Flows. Object result = Flow.eval('add(1, 2)'); | Method | Description | | ------ | ----------- | | eval(String) | Evaluate without context | | eval(String, Map&lt;String, Object&gt;) | Evaluate with context | Block Creation We can create a block like this: Block b = Flow.block(); Get Variable This is how we get the variable value. Flow f = new Flow() .var('n', Flow.getVar('a')); // Get the value of 'a' and set it to 'n' Call Functions This is how we call functions. Flow f = new Flow() .var('ret', Flow.call(R.constant.apply('a'))); // Set value 'a' to 'ret', by calling a 'constant' Func that always returns the value it has received | Method | Description | | ------ | ----------- | | call(Func) | Call the Func with no arguments | | call(Func, Object) | Call the Func with one argument | | call(Func, Object, Object) | Call the Func with two arguments | | call(Func, Object, Object) | Call the Func with three arguments | | call(Func, List&lt;Object&gt;) | Call the Func with a list of arguments | Add Custom Funcs We can add custom Funcs like this: Flow.addFuncs(new Map{ 'plus' = R.add }); Flow f = new Flow() .doReturn('plus(1, 2)'); | Method | Description | | ------ | ----------- | | addFuncs(Map&lt;String, Func&gt;) | Add a map of Funcs | | addFunc(String, Func) | Add Func with the name | | removeAllFuncs() | Remove all the Funcs | ","srcFilePath":"src/pages/docs/Methods/static.md","id":"static","location":"/docs/Methods/static.html","url":"/flow-apex/docs/Methods/static.html"}},"title":"Flow Methods","description":"Flow Methods","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} Flow Method Reference Here is the reference for Flow.apex. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('num = a + b') .doReturn('num'); Object result = f.run(1, 2); ","srcFilePath":"src/pages/docs/Methods/index.md","id":"Methods","location":"/docs/Methods/","url":"/flow-apex/docs/Methods/","childIds":["creation","function","block","static"]}},"childIds":["Flow","Methods","FlowScript","search"]},"tutorials":{"title":"Tutorials","description":"The tutorials","url":"/flow-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials/","customURL":true,"children":{"getting_started":{"title":"Getting Started","description":"The Getting Started Tutorial","tutorialTitle":"Getting started with Flow.apex","url":"/flow-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/getting_started/index.soy","id":"getting_started","location":"/tutorials/getting_started/","customURL":true,"children":{"step_1":{"title":"Installation","description":"Include Apex files","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Flow.apex has a dependency on R.apex and Script.apex. Please install these first. Include Flow.cls, and FlowTest.cls(optional) into your Org, and you are ready to go. If you want to use Func Package, please include FlowPackage.cls. You can check more on R.apex. ","srcFilePath":"src/pages/tutorials/getting_started/step_1.md","id":"step_1","location":"/tutorials/getting_started/step_1.html","url":"/flow-apex/tutorials/getting_started/step_1.html"},"step_10":{"title":"While Block","description":"While Block","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":10,"content":" {$page.title} We can use while blocks in Flow.apex like this. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('i = 0') .doWhile('i < 10', Flow.block() .var('output = debug(i)') .var('i = i + 1') ); ","srcFilePath":"src/pages/tutorials/getting_started/step_10.md","id":"step_10","location":"/tutorials/getting_started/step_10.html","url":"/flow-apex/tutorials/getting_started/step_10.html"},"step_11":{"title":"Break and Continue","description":"Break and Continue","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":11,"content":" {$page.title} We can use break and continue in any loop blocks. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('i = 0') .doWhile('i < 10', Flow.block() .doIf('i == 3', Flow.block() .doBreak() ) .var('output = debug(i)') .var('i = i + 1') ); ","srcFilePath":"src/pages/tutorials/getting_started/step_11.md","id":"step_11","location":"/tutorials/getting_started/step_11.html","url":"/flow-apex/tutorials/getting_started/step_11.html"},"step_12":{"title":"Switch Block","description":"Switch Block","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":12,"content":" {$page.title} We can use switch in Flows too. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('word = \"a\"') .doSwitch('word', new List{ 'a', Flow.block().var('output = debug(\"Matched\")'), 'b', Flow.block().var('output = debug(\"Not Matched\")') }); Also we can use break in switch blocks. ","srcFilePath":"src/pages/tutorials/getting_started/step_12.md","id":"step_12","location":"/tutorials/getting_started/step_12.html","url":"/flow-apex/tutorials/getting_started/step_12.html"},"step_13":{"title":"Recursion","description":"Recursion","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":13,"content":" {$page.title} With Flow.apex, recursion is not difficult to achieve. Flow f = new Flow() .inputAs('n').returnInteger() .doIf( 'n == 0', Flow.block() .doReturn(0) ) .var('ret = 2 + this(n - 1)') .doReturn('ret'); ","srcFilePath":"src/pages/tutorials/getting_started/step_13.md","id":"step_13","location":"/tutorials/getting_started/step_13.html","url":"/flow-apex/tutorials/getting_started/step_13.html"},"step_14":{"title":"Flow Debug","description":"Flow Debug","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":14,"content":" {$page.title} We can add debugging information anywhere we want in the block. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .debug(); debug will print all of the current variables in the block. ","srcFilePath":"src/pages/tutorials/getting_started/step_14.md","id":"step_14","location":"/tutorials/getting_started/step_14.html","url":"/flow-apex/tutorials/getting_started/step_14.html"},"step_2":{"title":"Preliminary Knowledge","description":"Preliminary Knowledge","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} It's recommended that you have a fair amount of knowledge on R.apex, but it's not required. Flow.apex uses Func objects from R.apex, and a Func is actually a custom Apex object that mimics the behavior of a function. Here is how your implement a custom Func. public class HelloWorldFunc extends Func { public HelloWorldFunc() { super(0); // specify the number of arguments the Func takes } // Provide custom implementation for a Func that takes 0 arguments. public override Object exec() { return 'Hello World'; } } And then you instantiate, and invoke it. Func helloworld = new HelloWorldFunc(); String msg = (String)helloworld.run(); To get deeper with Func objects, please check R.apex. ","srcFilePath":"src/pages/tutorials/getting_started/step_2.md","id":"step_2","location":"/tutorials/getting_started/step_2.html","url":"/flow-apex/tutorials/getting_started/step_2.html"},"step_3":{"title":"FlowScript","description":"FlowScript","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} Flow.apex has a built-in FlowScript to run Funcs dynamically. Previously, we run R.product like this: Object result = R.product.runN(new List{ 1, 2, 3, 4}); // Generate 24 from 1 * 2 * 3 * 4 Now with FlowScript, we have: Object result = Flow.eval('product(1, 2, 3, 4)'); // Generate 24 from 1 * 2 * 3 * 4 FlowScript makes invocations of Funcs more natural. ","srcFilePath":"src/pages/tutorials/getting_started/step_3.md","id":"step_3","location":"/tutorials/getting_started/step_3.html","url":"/flow-apex/tutorials/getting_started/step_3.html"},"step_4":{"title":"Flow Func Signature","description":"Flow Func Signature","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":4,"content":" {$page.title} A Flow is actually a Func. Func f = new Flow() .inputAs('a', 'b').returnInteger(); Here we create a Func of (a, b) = Integer, with an empty body. Or we can give it a name. Flow f = new Flow('f') .input('a', 'b').returnInteger(); This will add Func f to FlowScript, so that it can be referenced in the future. This definition creates a Func that takes a and b as arguments, and returns Integer. As a Flow is jsut a Func, we can use it wherever we can use Funcs. Object result = f.run(1, 2); // Call the Flow(Func) ","srcFilePath":"src/pages/tutorials/getting_started/step_4.md","id":"step_4","location":"/tutorials/getting_started/step_4.html","url":"/flow-apex/tutorials/getting_started/step_4.html"},"step_5":{"title":"Variable Assignment","description":"Variable Assignment","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":5,"content":" {$page.title} We can do variable assignment in Flows. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('num = 0'); Here we created a local variable num with the value of 0. Flows have global variables and local variables. Any variable that is passed from outside is a global one. Any variable that is created inside the Flow is a local one. Variables cannot share the same names, so there is no variable overridden in Flow.apex. ","srcFilePath":"src/pages/tutorials/getting_started/step_5.md","id":"step_5","location":"/tutorials/getting_started/step_5.html","url":"/flow-apex/tutorials/getting_started/step_5.html"},"step_6":{"title":"Function Invocation","description":"Function Invocation","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":6,"content":" {$page.title} We can invoke functions in Flows. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('num = add(a, b)'); Here we assign the value of num to be the result of calling add(a, b). Funcs from R.apex are imported in Flow.apex. If you want to import custom Funcs, see below. Flow.addFunc('plus', R.add); This will register the Func R.add in the name of plus. So you can refer it now in FlowScript. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .var('num = plus(a, b)'); ","srcFilePath":"src/pages/tutorials/getting_started/step_6.md","id":"step_6","location":"/tutorials/getting_started/step_6.html","url":"/flow-apex/tutorials/getting_started/step_6.html"},"step_7":{"title":"Return Statement","description":"Return Statement","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":7,"content":" {$page.title} returnXxx in Flow.apex only specifies what type of result is returned. To actually return something, call doReturn(Object) or doReturnRaw(Object). Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doReturn(0); If no doReturn or equivalent is added, the Flow Func will return null. The difference between doReturn and doReturnRaw is that doReturn treats String as FlowScript while doReturnRaw does not. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doReturn('\"message\"'); is equivalent to Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doReturnRaw('message'); ","srcFilePath":"src/pages/tutorials/getting_started/step_7.md","id":"step_7","location":"/tutorials/getting_started/step_7.html","url":"/flow-apex/tutorials/getting_started/step_7.html"},"step_8":{"title":"If Block","description":"If Block","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":8,"content":" {$page.title} Flow.apex supports if and if not blocks. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doIf( 'a == 1', Flow.block().doReturn(1) ); And we can append the else block too. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doIf( 'a == 1', Flow.block().doReturn(1), Flow.block().doReturn(2) ); Here if needs at least one block. A block in Flow.apex is actually a block of executable statements. We can use the blocks to extend our logic. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doIf( 'a == 1', Flow.block() .var('b = 2') // more logic goes on here .doReturn(1) ); ","srcFilePath":"src/pages/tutorials/getting_started/step_8.md","id":"step_8","location":"/tutorials/getting_started/step_8.html","url":"/flow-apex/tutorials/getting_started/step_8.html"},"step_9":{"title":"For Block","description":"For Block","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":9,"content":" {$page.title} We support two types of for blocks in Flow.apex. Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doFor('i = 0; i < 10; i = i + 1', Flow.block() .var('output = debug(i)') ); Or Flow f = new Flow() .inputAs('a', 'b').returnInteger() .doFor('i in range(0, 10)', Flow.block() .var('output = debug(i)') ); ","srcFilePath":"src/pages/tutorials/getting_started/step_9.md","id":"step_9","location":"/tutorials/getting_started/step_9.html","url":"/flow-apex/tutorials/getting_started/step_9.html"}},"childIds":["step_1","step_2","step_3","step_4","step_5","step_6","step_7","step_8","step_9","step_10","step_11","step_12","step_13","step_14"]}},"childIds":["getting_started"]}},"childIds":["docs","tutorials"]},"basePath":"/flow-apex"}